
#ifndef V_CAM_NODELET_HPP_
#define V_CAM_NODELET_HPP_


#include <cstdlib>
#include <vector>
#include <nodelet/nodelet.h>
#include <ros/package.h>
#include <ros/ros.h>
// #include <dynamic_reconfigure/server.h>
// #include <image_transport/image_transport.h>
// #include <image_geometry/pinhole_camera_model.h>
#include <sensor_msgs/Image.h>
// #include <sensor_msgs/CameraInfo.h>
// #include <mavros_msgs/CamIMUStamp.h>
// #include <sensor_msgs/SetCameraInfo.h>
// #include <std_msgs/Int16.h>
// #include <std_srvs/Trigger.h>
// #include <vcam/Exposure.h>
// #include <vcam/VCamConfig.h>
// #include <boost/thread/mutex.hpp>
// #include <camera_calibration_parsers/parse.h>
// #include <sensor_msgs/fill_image.h>
// #include <sensor_msgs/image_encodings.h>
// #include <cv_bridge/cv_bridge.h>
// #include <opencv2/highgui/highgui.hpp>
// #include <opencv2/imgproc/imgproc.hpp>
// #include <vcam/cam_driver.h>
// #include <vcam/device.h>


namespace vio_cam {


// typedef dynamic_reconfigure::Server<vio_cam::VCamConfig> ReconfigureServer;


class VCamNodelet : public nodelet::Nodelet {
public:
  constexpr static unsigned int RECONFIGURE_RUNNING = 0;
  constexpr static unsigned int RECONFIGURE_STOP = 1;
  constexpr static unsigned int RECONFIGURE_CLOSE = 3;
  constexpr static int DEFAULT_IMAGE_WIDTH = 640;  // NOTE: these default values do not matter, as they
  constexpr static int DEFAULT_IMAGE_HEIGHT = 480; // are overwritten by queryCamParams() during connectCam()
  constexpr static double DEFAULT_EXPOSURE = 30.0;
  constexpr static double DEFAULT_FRAME_RATE = 10.0;
  constexpr static int DEFAULT_PIXEL_CLOCK = 25;


  const static std::string DEFAULT_FRAME_NAME;
  const static std::string DEFAULT_CAMERA_NAME;
  const static std::string DEFAULT_CAMERA_TOPIC;
  const static std::string DEFAULT_TIMEOUT_TOPIC;
  const static std::string DEFAULT_COLOR_MODE;


  VCamNodelet();

  virtual ~VCamNodelet();

  /**
   * Initializes ROS environment, loads static ROS parameters, initializes  camera,
   * and starts live capturing / frame grabbing thread.
   */
  virtual void onInit();

  /**
   * Handles callbacks from dynamic_reconfigure.
   */
  // void configCallback(vcam::VCamConfig& config, uint32_t level);


protected:
  // vio_cam::Camera cam;
  // vio_cam::Devices dev;
  // std::string cam_name;
  // std::string video_node;
  // std::string dev_node_name="/dev/";
  /**
   * Calls VCamDriver::syncCamConfig(), then updates ROS camera info
   * and ROS image settings.
   */
  // virtual INT syncCamConfig(std::string dft_mode_str = "mono8");

  /**
   * Reads parameter values from currently selected camera.
   */
  // INT queryCamParams();

  /**
   * Loads, validates, and updates static ROS parameters.
   */
  // INT parseROSParams(ros::NodeHandle& local_nh);

  /**
   * Initializes the camera handle, loads VCAM INI configuration, refreshes
   * parameters from camera, loads and sets static ROS parameters, and starts
   * the frame grabber thread.
   */
  virtual std::int32_t connectCam();

  /**
   * Stops the frame grabber thread, closes the camera handle,
   * and releases all local variables.
   */
  virtual std::int32_t  disconnectCam();

  /**
   * (ROS Service) Updates the camera's std::int32_t rinsic parameters over the ROS topic,
   * and saves the parameters to a flatfile.
   */
  // bool setCamInfo(sensor_msgs::SetCameraInfo::Request& req,
  //     sensor_msgs::SetCameraInfo::Response& rsp);

  /**
   * Loads the camera's intrinsic parameters from camIntrFilename.
   */
  // void loadIntrinsicsFile();


  /**
   * Saves the camera's intrinsic parameters to camIntrFilename.
   */
  // bool saveIntrinsicsFile();

  /**
   * Main ROS interface "spin" loop.
   */
  void frameGrabLoop();
  void startFrameGrabber();
  void stopFrameGrabber();

  const static std::map<std::int32_t , std::string> ENCODING_DICTIONARY;
  /**
   * Transfers the current frame content into given sensor_msgs::Image,
   * therefore writes the fields width, height, encoding, step and
   * data of img.
   */
  bool fillMsgData(sensor_msgs::Image& img) const;

  /**
   * Returns image's timestamp or current wall time if driver call fails.
   */
  ros::Time getImageTimestamp();

  /**
   * Returns image's timestamp based on device's internal clock or current wall time if driver call fails.
   */
  ros::Time getImageTickTimestamp();

  // virtual void handleTimeout();

  // std::thread frame_grab_thread_;
  bool frame_grab_alive_;

  // ReconfigureServer* ros_cfg_;
  // boost::recursive_mutex ros_cfg_mutex_;
  // bool cfg_sync_requested_;

  // image_transport::CameraPublisher ros_cam_pub_;
  // sensor_msgs::Image ros_image_;
  // sensor_msgs::CameraInfo ros_cam_info_;
  unsigned int ros_frame_count_;
  ros::Publisher timeout_pub_;
  unsigned long long int timeout_count_;


  // ros::ServiceServer set_cam_info_srv_;

  std::string frame_name_;
  std::string cam_topic_;
  std::string timeout_topic_;
  std::string cam_intr_filename_;
  std::string cam_params_filename_; // should be valid UEye INI file
  // vcam::VCamConfig cam_params_;

  ros::Time init_ros_time_; // for processing frames
  uint64_t init_clock_tick_;

  ros::Time init_publish_time_; // for throttling frames from being published (see cfg.output_rate)
  uint64_t prev_output_frame_idx_; // see init_publish_time_
  // boost::mutex output_rate_mutex_;
};


} // namespace ueye_cam


#endif /* VCAM_NODELET_HPP_ */